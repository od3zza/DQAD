<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Remixador de Imagens</title>

  <style>
    /* Reset b√°sico */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      background-color: #000;
      color: #fff;
      font-family: 'Helvetica Neue', sans-serif;
      height: 100%;
      overflow-x: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      width: 100%;
      text-align: center;
      min-height: 100vh;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 1.5rem;
      letter-spacing: 1px;
    }

    .controls {
      margin-bottom: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    input[type="file"] {
      color: #fff;
      background: transparent;
      border: 1px solid #333;
      padding: 0.5rem;
      border-radius: 4px;
    }

    button {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.8rem 1.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: bold;
      border-radius: 4px;
    }

    button:hover {
      background-color: #fff;
      color: #000;
      transform: translateY(-2px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #canvasContainer {
      margin: 1rem 0;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-grow: 1;
    }

    #canvasContainer canvas {
      max-width: 95vw;
      max-height: 70vh;
      border: 1px solid #333;
      border-radius: 8px;
    }

    .status {
      margin-top: 1rem;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    #downloadLink {
      margin-top: 1rem;
      font-size: 0.9rem;
      transition: opacity 0.2s ease;
    }

    #downloadLink:hover {
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé® Remixador de Arte Digital</h1>
    
    <div class="controls">
      <input type="file" id="imageInput" multiple accept="image/png, image/jpeg, image/webp" />
      <button id="remixButton" disabled>Remixar Imagens</button>
    </div>
    
    <div id="canvasContainer"></div>
    <div id="status" class="status">Selecione imagens para come√ßar</div>
    <a id="downloadLink" href="#" style="display: none; color: #fff; text-decoration: underline; margin-top: 1rem;">baixar em alta resolu√ß√£o (1920x1920)</a>
  </div>
 
  <script>
    let loadedImages = [];
    let remixReady = false;
    let cnv;
    let lastGeneratedImage = null; // Armazena a √∫ltima imagem gerada
    let highResImage = null; // Armazena a vers√£o em alta resolu√ß√£o

    // Calcula tamanho do canvas baseado na tela
    function getCanvasSize() {
      const maxWidth = Math.min(window.innerWidth * 0.9, 800);
      const maxHeight = Math.min(window.innerHeight * 0.6, 600);
      const size = Math.min(maxWidth, maxHeight);
      return size;
    }

    function setup() {
      const canvasSize = getCanvasSize();
      cnv = createCanvas(canvasSize, canvasSize);
      cnv.parent("canvasContainer");
      noLoop();
      background(20);
      
      // Desenha placeholder
      fill(40);
      noStroke();
      rect(50, 50, width-100, height-100, 10);
      fill(100);
      textAlign(CENTER, CENTER);
      textSize(16);
      text("Canvas pronto para suas imagens", width/2, height/2);
    }

    // Redimensiona quando a janela muda
    function windowResized() {
      const canvasSize = getCanvasSize();
      resizeCanvas(canvasSize, canvasSize);
      
      // Se h√° uma imagem gerada, redesenha ela
      if (lastGeneratedImage) {
        background(20);
        image(lastGeneratedImage, 0, 0, width, height);
        updateStatus("Canvas redimensionado - imagem mantida");
      } else if (loadedImages.length === 0) {
        background(20);
        fill(40);
        noStroke();
        rect(50, 50, width-100, height-100, 10);
        fill(100);
        textAlign(CENTER, CENTER);
        textSize(16);
        text("Canvas redimensionado", width/2, height/2);
      }
    }

    document.getElementById("imageInput").addEventListener("change", handleImageUpload);
    document.getElementById("remixButton").addEventListener("click", remixImages);

    function updateStatus(message) {
      document.getElementById("status").textContent = message;
    }

    function handleImageUpload(event) {
      loadedImages = [];
      const files = event.target.files;
      const button = document.getElementById("remixButton");

      if (files.length === 0) {
        button.disabled = true;
        updateStatus("Selecione imagens para come√ßar");
        return;
      }

      updateStatus(`Carregando ${files.length} imagem(ns)...`);
      button.disabled = true;

      let count = 0;
      for (let file of files) {
        const reader = new FileReader();
        reader.onload = function (e) {
          loadImage(e.target.result, (img) => {
            loadedImages.push(img);
            count++;
            updateStatus(`Carregadas ${count}/${files.length} imagens`);
            
            if (count === files.length) {
              remixReady = true;
              button.disabled = false;
              updateStatus(`${files.length} imagem(ns) prontas para remix!`);
            }
          });
        };
        reader.readAsDataURL(file);
      }
    }

    function blendImagesSmart(targetWidth = width, targetHeight = height) {
      let combined = createGraphics(targetWidth, targetHeight);
      combined.background(20);

      for (let i = 0; i < loadedImages.length; i++) {
        let img = loadedImages[i];
        
        // Redimensiona imagem para caber no canvas
        let scaleFactor = Math.min(targetWidth / img.width, targetHeight / img.height) * 0.8;
        let imgW = img.width * scaleFactor;
        let imgH = img.height * scaleFactor;

        for (let j = 0; j < 4; j++) {
          let maskType = floor(random(4));

          if (maskType === 0) {
            // M√°scaras circulares
            combined.push();
            combined.translate(random(targetWidth), random(targetHeight));
            combined.beginClip();
            combined.ellipse(0, 0, random(80 * targetWidth/800, 300 * targetWidth/800));
            combined.endClip();
            combined.image(img, -imgW / 2, -imgH / 2, imgW, imgH);
            combined.pop();
          } else if (maskType === 1) {
            // Fatias verticais
            let x = floor(random(targetWidth - 100 * targetWidth/800));
            let sliceWidth = random(20 * targetWidth/800, 100 * targetWidth/800);
            combined.copy(img, x, 0, sliceWidth, img.height, 
                         x + random(-30 * targetWidth/800, 30 * targetWidth/800), 0, sliceWidth, targetHeight);
          } else if (maskType === 2) {
            // Rota√ß√£o e transpar√™ncia
            combined.push();
            combined.translate(random(targetWidth), random(targetHeight));
            combined.rotate(random(-PI / 3, PI / 3));
            combined.tint(255, random(60, 150));
            combined.image(img, -imgW / 2, -imgH / 2, imgW, imgH);
            combined.pop();
          } else {
            // Blocos retangulares
            let blockW = random(50 * targetWidth/800, 200 * targetWidth/800);
            let blockH = random(50 * targetHeight/800, 200 * targetHeight/800);
            let sx = random(img.width - blockW);
            let sy = random(img.height - blockH);
            let dx = random(targetWidth - blockW);
            let dy = random(targetHeight - blockH);
            combined.copy(img, sx, sy, blockW, blockH, dx, dy, blockW, blockH);
          }
        }
      }

      return combined;
    }

    function remixImages() {
      if (!remixReady || loadedImages.length === 0) {
        updateStatus("Carregue imagens antes de remixar!");
        return;
      }

</head>
<body>
  <div class="container">
    <h1>üé® Remixador de Arte Digital</h1>
    
    <div class="controls">
      <input type="file" id="imageInput" multiple accept="image/png, image/jpeg, image/webp" />
      <button id="remixButton" disabled>Remixar Imagens</button>
    </div>
    
    <div id="canvasContainer"></div>
    <div id="status" class="status">Selecione imagens para come√ßar</div>
    <a id="downloadLink" href="#" style="display: none; color: #fff; text-decoration: underline; margin-top: 1rem;">baixar em alta resolu√ß√£o (1920x1920)</a>
  </div>
      updateStatus("Criando remix...");
      background(20);
      
      // Gera vers√£o para exibi√ß√£o
      let combined = blendImagesSmart();
      applyGlitch(combined);
      image(combined, 0, 0, width, height);
      
      // Gera vers√£o em alta resolu√ß√£o (1920x1920)
      updateStatus("Gerando vers√£o em alta resolu√ß√£o...");
      let highResCombined = blendImagesSmart(1920, 1920);
      applyGlitch(highResCombined);
      
      // Salva a imagem combinada (antes do glitch externo)
      lastGeneratedImage = combined;
      highResImage = highResCombined;

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
      updateStatus("Aplicando efeitos glitch...");

      // Configura o download da vers√£o alta resolu√ß√£o imediatamente
      const highResDataURL = highResCombined.elt.toDataURL();
      setupDownloadLink(highResDataURL);

      setTimeout(() => {
        const originalDataURL = cnv.elt.toDataURL();

        // Aplica glitch apenas na vers√£o de exibi√ß√£o
        window.glitchCanvas({
          amount: random(60, 100),
          quality: random(15, 30),
          seed: Math.floor(Math.random() * 9999),
          iterations: floor(random(8, 15))
        })
        .fromDataURL(originalDataURL)
        .toDataURL()
        .then((glitchedDataURL) => {
          loadImage(glitchedDataURL, (p5img) => {
            background(20);
            image(p5img, 0, 0, width, height);
            
            // Salva a vers√£o final com glitch
            lastGeneratedImage = createGraphics(width, height);
            lastGeneratedImage.image(p5img, 0, 0, width, height);
            
            updateStatus("Remix conclu√≠do! Link de download dispon√≠vel abaixo.");
          });
        })
        .catch((error) => {
          console.error("Erro no glitch:", error);
          updateStatus("Remix conclu√≠do! Link de download dispon√≠vel abaixo.");
        });
      }, 200);
    }

    function applyGlitch(pg) {
      const w = pg.width;
      const h = pg.height;
      
      // Ajusta os valores baseado no tamanho da imagem
      const scaleFactor = w / 800;

      // Cortes horizontais aleat√≥rios
      for (let i = 0; i < 60 * scaleFactor; i++) {
        const sx = floor(random(w));
        const sy = floor(random(h));
        const sw = floor(random(10 * scaleFactor, 80 * scaleFactor));
        const sh = floor(random(3 * scaleFactor, 30 * scaleFactor));
        const dx = sx + floor(random(-80 * scaleFactor, 80 * scaleFactor));
        const dy = sy + floor(random(-50 * scaleFactor, 50 * scaleFactor));
        pg.copy(pg, sx, sy, sw, sh, dx, dy, sw, sh);
      }

      // Quebras de scanline
      for (let i = 0; i < 15 * scaleFactor; i++) {
        let y = floor(random(h));
        let hStrip = floor(random(1, 8 * scaleFactor));
        let offset = floor(random(-100 * scaleFactor, 100 * scaleFactor));
        pg.copy(pg, 0, y, w, hStrip, offset, y, w, hStrip);
      }

      // Ru√≠do nos pixels
      pg.loadPixels();
      for (let i = 0; i < pg.pixels.length; i += 4) {
        if (random() < 0.02) {
          pg.pixels[i] = random(255);
          pg.pixels[i + 1] = random(100);
          pg.pixels[i + 2] = random(255);
        }
        
        if (random() < 0.05) {
          const noise = random(-40, 40);
          pg.pixels[i] = constrain(pg.pixels[i] + noise, 0, 255);
          pg.pixels[i + 1] = constrain(pg.pixels[i + 1] + noise, 0, 255);
          pg.pixels[i + 2] = constrain(pg.pixels[i + 2] + noise, 0, 255);
        }
      }
      pg.updatePixels();

      // Blocos coloridos aleat√≥rios
      for (let i = 0; i < 8 * scaleFactor; i++) {
        let blockSize = floor(random(5 * scaleFactor, 30 * scaleFactor));
        let px = floor(random(0, w - blockSize));
        let py = floor(random(0, h - blockSize));
        pg.noStroke();
        pg.fill(random(255), random(100), random(255), random(100, 200));
        pg.rect(px, py, blockSize, blockSize);
      }
    }

    function setupDownloadLink(dataURL) {
      const downloadLink = document.getElementById("downloadLink");
      downloadLink.href = dataURL;
      downloadLink.download = `remix-arte-${Date.now()}.png`;
      downloadLink.style.display = "inline-block";
    }
  </script>
</body>
</html>
